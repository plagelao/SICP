---
layout: post
title: Section 1.2.2
date: 2011-07-04 13:00:00 +00:00
categories:
  - sicp
  - scheme
  - lisp
---
Using the Fibonacci sequence, the authors explain what [tree recursion is](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2).

Let's have a look at the exercises for this section:

- Exercise 1.11 A function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n> 3. Write a procedure that computes f by means of a recursive process. Write a procedure that computes f by means of an iterative process.

  Let's start with the recursive one:

        (define (f-recursive n)
          (if (< n 3)
            n
            (+ (f-recursive (- n 1))
               (* 2 (f-recursive (- n 2)))
               (* 3 (f-recursive (- n 3))))))

  This is a perfect example of tree recursion. In order to get the n element we need to know the n-1, n-2 and n-3 elements. But, in order to know, for example, the n-2 element, we need to know the n-3 (again), n-4 and n-5... This is not very efficient, we can do something better (for this problem). 's try the iterative one:

        (define (f-iterative n)
          (define (f-iter a b c count)
            (if (= count 0)
              c
              (f-iter (+ a
                         (* 2 b)
                         (* 3 c))
                      a
                      b
                      (- count 1))))
          (f-iter 2 1 0 n))

- Exercise 1.12 The following pattern of numbers is called Pascal's triangle.

            1
           1 1
          1 2 1
         1 3 3 1
        1 4 6 4 1
           ...

  The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it.35 Write a procedure that computes elements of Pascal's triangle by means of a recursive process.

  And here you can see my solution:

  (define (pascal-triangle pow coefficient)
    (cond ((= pow 1) 1)
          ((= coefficient 1) 1)
          ((= coefficient pow) 1)
          (else (+ (pascal-triangle (- pow 1) coefficient)
                   (pascal-triangle (- pow 1) (- coefficient 1))))))

  Again, we are using tree recursion. We can improve the algorithm using what the authors call "memoization", but I leave that to you :D

- Exercise 1.13 Prove that Fib(n) is the closest integer to (&phi;^n)/&radic;5, where &phi;  = (1 + &radic;5)/2. Hint: Let &psi; = (1 - &radic;5)/2. Use induction and the definition of the Fibonacci numbers (see section 1.2.2) to prove that Fib(n) = (&phi;^n - &psi;^n)/&radic;5.

  Mathematics! It has been a long time since my last induction proof, but let's try it.

  Ok, so we start with:

  Fib(1) = (&phi; - &psi;)/&radic;5
  Fib(1) = ((1 + &radic;5)/2 - (1 - &radic;5)/2)/&radic;5
  Fib(1) = 2&radic;5/2/&radic;5 = 1

  Now with the number 2:

  Fib(2) = (&phi;^2 - &psi;^2)/&radic;5
  Fib(2) = ((1 + &radic;5)^2/4 - (1 - &radic;5)^2/4)/&radic;5
  Fib(2) = ((1 + 5 + 2&radic;5)/4 - (1 + 5 - 2&radic;5)/4)/&radic;5
  Fib(2) = ((1 + 5 + 2&radic;5 - 1 - 5 + 2&radic;5)/4)/&radic;5
  Fib(2) = ((2&radic;5 + 2&radic;5)/4)/&radic;5
  Fib(2) = (4&radic;5/4)/&radic;5
  Fib(2) = &radic;5/&radic;5
  Fib(2) = 1

  It works! I'm not going to do 3. Feel free to do it yourself. Let's do n+1 instead :D

  Fib(n + 1) = Fib(n) + Fib(n - 1)

  also

  Fib(n + 1) = (&phi;^(n+1) - &psi;^(n+1))/&radic;5

  and

  Fib(n) + Fib(n-1) = (&phi;^n - &psi;^n)/&radic;5  +
                      (&phi;^(n-1) - &psi;^(n-1))/&radic;5

  Ok. Let's concentrate on Fib(n) + Fib(n - 1):


  Fib(n) + Fib(n-1) = ((&phi;^n + &phi;^(n-1)) -
                      (&psi;^n + &psi;^(n-1)))/&radic;5

  Fib(n) + Fib(n-1) = (&phi;^(n-1)(1 + &phi;) -
                      (&psi;^(n-1)(1 + &psi;)))/&radic;5

  Now we have to proof that:

  &phi;^(n+1) = &phi;^(n-1)(1 + &phi;)
  &psi;^(n+1) = &psi;^(n-1)(1 + &psi;)

  Let's start with &phi;. We know that &phi;^2 = &phi; + 1, so:

  &phi;^(n+1) = &phi;^(n-1)(1 + &phi;)
  &phi;^(n-1)(&phi;^2) = &phi;^(n-1)(1 + &phi;)

  If we remove &phi;^(n-1) we get:

  (&phi;^2) = (1 + &phi;)

  So we have proof that &phi;^(n+1) = &phi;^(n-1)(1 + &phi;) is true. Let's do the same with &psi;


  &psi;^(n+1) = &psi;^(n-1)(1 + &psi;)
  &psi;^(n-1)(&psi;^2) = &psi;^(n-1)(1 + &psi;)
  &psi;^2 = 1 + &psi;
  ((1 - &radic;5)/2)^2 = (6 - 2&radic;5)/2 = (3 - &radic;5)/2
  1 + ((1 - &radic;5)/2) = (2 + 1 - &radic;5)/2
                                = (3 - &radic;5)/2

  Yes! We got our proof.

As always, you can find [my solutions in my github](https://github.com/plagelao/SICP/tree/master/exercises/chapter-1).
See you on section 1.2.3!
